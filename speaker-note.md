# MySQL-blockchain のSpeakerNote

みなさんこんにちは。
引き続き私の方から発表をさせていただきますよろしくおねがいします。
「MySQL8.0でブロックチェーンを実装する」という内容でお話させていただきます。

まずはじめに簡単に自己紹介をさせていただきます。


# 自己紹介1

森崎雅之といいますよろしくおねがいします。
@masayuki14 というアカウントでツイッターとかブログとかやってます。
主に技術系の記事をかいてます。
よかったらフォローしくてください。

# 自己紹介2

主な職業は「主夫」です。
保育園に通う子供が二人います。
で、妻がフルタイムで働いてまして、京都から大阪まで通勤しているのでけっこう仕事での拘束時間が長いんですね。
それで私が家事・育児全般やってまして、空いた時間でフリーランスとして
Web系のソフトウェアエンジニアとして働いてます。

一般的な共働きの夫婦の男女が逆になっている感じです。
（なので皆さんの奥さんが勉強会でしゃべってる、って考えてもらえば想像しやすいんじゃないかと思います。）

===

あとはコミュニティ活動をやってまして、
はんなりPythonというパイソンコミュニティで月1回京都で勉強会をやってます。

そしてOSSGateというコミュニティですね。
これはOSS開発に参加する人を増やしていこう、という取り組みをしているコミュニティです。
来月大阪でワークショップがあるので、
OSS開発に興味あるけどどうしていいかわからない、という方がいましたら是非参加してください。
来月の11月24日に開催しますのでよろしくおねがいします。

京都でもたまに開催するんですが、
会場がなかなか見つけられないので、
会場提供しますよーという方いましたら、
是非お声がけいただければとおもいます。

===

そして、最後ですけど、スプーキーズアンバサダーという肩書があります。
アンバサダーというと「大使」という意味なんですが、大使館の大使ですね。
スプーキーズというのは企業の名前で京都の会社です。
それで、こういう勉強会などの場で発表したりするついでに、
ちょっとだけ会社の紹介をしよう、というのが役割なので、
少しだけ紹介させてください。

# スプーキーズ

スプーキーズは京都の会社で、
主にWeb系のシステム開発をおこなっています。
最近ではソーシャルゲームの開発・運用を手がけてまして
現状で3タイトルやってます。

DB関連でいうと、MySQLはもちろんですが、
PerconaServerやMariaDBといったMySQLの派生DBもつかておりまして、
3タイトル合計で20台ほどのデータベース・サーバーを運用しています。

Web系エンジニアを積極採用しておりますので、
もしある程度の規模のDB開発・運用をやってみたい、
という方がいましたら、
その選択肢の一つに加えていただければいいなと思います。
よろしくおねがいします。


# スプーキーズ

また、`テクテクテック` という勉強会を開催しています。
毎回いろいろなテーマで開催していて
次回は `picoCTF2018`というセキュリティコンテストの参加者による問題の解説会を
2018/11/14(水)に
そして来年ですが、DB勉強会も予定します。

DB勉強会では、大規模ゲーム開発運営で経験した話を主にするので
興味のある方は是非ご参加ください。

DBについて何か発表して頂ける方は是非ご連絡ください!!

# 概要

それでは本題に入っていきます。

> MySQL8.0を使って
> 簡略化したブロックチェーンモデルを
> 実装した

概要はこのようになっています。

この発表は、京都のBlockchain勉強会で話した内容なんですが、
MySQL8.0をつかいたい！！というのが動機でやった発表なので
あんまりブロックチェーンのことは触れてません。
今回発表するにあたってブラッシュアップしています。

# やったこと

やったことですね。

大きく2つです。
ブロックチェーンのデータ構造をテーブルで表現しました。
それに対してブロックの追加やマイニングを行うプログラムを
Javascripで実装してMySQLShellで実行しています。

# つかっているもの

なので使っている技術要素というと
- MySQL 8.0　最新のものです
- MySQL Shell こちらも最新の8.0.12です
- Javascript

の3つが基本的な技術要素になります

# MySQL 8.0

MySQL8.0では当然ですが、データベースとして使っています。
ブロックチェーンのデータ構造をテーブルを使って表現しています。

データ構造のなかで、トランザクションと呼ばれる取引を保存する部分があるんですが、
ここでJSON型を使っています。
MySQLでは5.7からJSON型がサポートされてます。

# MySQL Shel

MySQLShellはCLIのクライアントツールで、
今回はDBアクセスのインタフェースとして使っています。

MySQL5.7から追加されているX Protocolをサポートしていて、
SQL、Python、Javascriptの3つの方法でDBの操作がかのうになっています。
今回はJavascriptを使っています。

# Javascript

ブロックチェーンのブロックデータの追加であったり、
マイニングを行うプログラムをJavascriptで実装しています。

実行環境としてMySQLShellを使っています。
こちらはのちほど実際に動かしているものをお見せしようと思います。


# ブロックチェーンの簡易モデル説明

では、ブロックチェーンとは何なんだ、ということなんですけども、

ブロックチェーンは「ブロック」と呼ばれるデータの単位を
鎖のようにつないでいって、データを保持するデータベースでなんですね。

そこにいろんな技術要素があって
分散型のネットワークであるとか、合意形成のアルゴリズムであるとか
スマートコントラクトであるとか、
いろんな意味を含んでいるんですけども、

今回はデータ構造としてのブロックチェーンという部分だけを対象にしています。

それで図にするとこんな感じです

# ブロックチェーンの図

ブロックと呼ばれるデータの塊が、鎖のようにつながっているもの、です。
リストやツリーの構造と似たようなものです。

ブロックは次の3つの要素で構成されています。

- 取引（トランザクション）
- ナンス（乱数）
- 前のブロックのHash値

この3つで構成されています。
前のブロックのHash値を持っているのでこれが鎖のようにつながっていきます。
このブロックのHash値が次のブロックに含められると、
いうかたちになっています。

で、マイニングとはなにかですが、
（図を見ながら）
このブロックのハッシュ値を作るあたって、制約があるんですね。
それを満たすようなナンスを探さないといけない。

それがマイニングと呼ばれるものです。

# マイニングとは

生成するHash値には制約があります。
その制約を満たすHash値になるようにナンスを探すことを
マイニングと呼びます。

# マイニング例

例えば *Hash値の先頭には0が10個並ばないといけない* という制約のばあい
それを満たすようなナンスを探していきます。
ナンスを変えてハッシュ値を計算する、というのを何度も繰り返してナンス見つける。
それをマイニングと呼んでいます。

今回はこの条件を先頭に0を4つ、Hash関数をMD5にしてやってみました。

で、これらを実際にMySQLを使って実装していきます。

# 実行環境

では実行環境を見ていきます。
先程の図の、ブロック1つをレコードとして保持して、
テーブル全体でブロックチェーンを作りました。

Hash関数にはmd5を使って、Hashの制約には先頭に0が4つ続くもの、としています。

# テーブル定義

テーブル定義はこのようになっています。

トランザクションをJSONにして、どんなフォーマットでも持てるようになっています。
あとはナンスと前のハッシュ値、そしてこのブロックのハッシュ値を持つようにしています。

# トランザクションの例

トランザクションなんですが、
仮想通貨の場合はでは取引なので、誰が誰にいくら送金した、みたいなデータが保存されますが、
今回はこんな形にしてます。

実際は何でもいいです。

これだと、'name' 'date' 'report' というキーにそれぞれデータが入ってます。


# DEMO

では実際に動くものを見てもらいたいと思います。
ブロックを追加して、マイニングをする、
そしていくつかブロックを追加して
チェーンをつくっていく、というのをやってみたいと思います。

# DEMO


まず、MySQL Shellを起動します。mysqlコマンドのように引数でユーザーとパスワードを指定しています。
```
$ mysqlsh -u root -p
```

# DEMO

このように session という変数が事前定義されているのでこれを使って、テーブルのオブジェクトを取得します。

```
table = session.getSchema('blockchain').getTable('block')
```

タブで補完できるので、関数一覧がこのようにみれますが、

```
table. <tab>
```

help()関数でもリファレンスが参照できます。

```
table.help()
```

select()関数で、データが取得できます。

```
table.select()
```

まだ空っぽなので0件です。


では、データを登録してみます。

```
table.insert({transaction: [{'name': 'morisaki'}], prev_hash: ''}) 
```
このようにカラムをキーにしたオブジェクトを渡すことで、データのInsertができます。

```
table.select()  // INSERTしたデータが参照できる
```
データ入ってますね。

もちろんWhere句もつかえて
```
table.select().where('id = :id').bind('id', 1)
```

こんなふうにプレースホルダーも利用できます。

# DEMO

ここでSQLの実行もしてみましょう。
モードが切り替えられます。

```sql
\sql
use blockchain

select * From block;
show create table block;
```

このようにmysqlクライアントと同じことができます。
なので、とりあえずmysqlshに乗り換えよう、ということをオススメします。

# DEMO mining

ではマイニングをしてみます。
プログラムはこんなふうに書いてます。
（スライドに切り替え）

この関数は起動時にロードする設定にしているので、
この環境だとすぐ動くようになっています。

お見せしたようにtableからidでデータを取得して
ナンスを変えながら繰り返しハッシュ値を計算しています。
見つかったらupdateで更新しておわり、という内容です。

```javascript
mining = function (id) {

  schema = session.getSchema('blockchain')
  table = schema.getTable('block')
  record = table.select().where('id = :id')
    .bind('id', id).execute().fetchOne()

  nonce = 0
  while (true) {
    hash = md5(record.transaction + nonce + record.prev_hash)
    // 条件に一致するHash値になれば終了
    if (hash.match(/^0000/)) {
      table.update()
        .set('hash', hash).set('nonce', nonce)
        .where('id = :id').bind('id', record.id)
        .execute()
      break
    }
    nonce++
  }
}
```

# マイニングデモ

では実行してみます。

```
mining(1)
```

結果として、ナンスとハッシュ値が出力されます。
ハッシュ値の先頭に0が4つ続いています。
セレクトしてみると、ナンスとハッシュ値が更新されています。

```
table.select()
```

ではいくつかデータを追加してチェーンを繋いでいきます。
で、省略のためにいくつか事前に定義した関数を使います。

```
// id => hash 指定IDのHash値を返す
id2hash(1)
```
これは、idからハッシュ値をひいてくる関数で、前のブロックのハッシュ値を得るのに使います。

```
format(1, [])
```

これはinsert用のオブジェクトを返す関数で、
1つ目の引数が先程の関数を使ってハッシュ値に変換していていて、2つ目の引数がトランザクションの値になる
オブジェクトが返ります。

これを使ってブロックを追加していきます。


```
format(1, [{"name":"mysql"}, {"name":"masayuki", "date":"2018-10-14"}])

table.insert(format(1, [{"name":"yoshida", "date":"2018-10-15"}]))
mining(2)
table.insert(format(2, [{"name":"tanaka", "date":"2018-10-16"}]))
mining(3)
table.insert(format(3, [{"name":"okamura", "date":"2018-10-17"}]))
mining(4)
```

これで4つのブロックを追加してチェーンを繋いできました。
セレクトしてみます。

```
table.select()
```


という用な感じでMySQL Shellを使うとjavascriptのプログラムでいろいろとデータのが操作できますので、
バッチ処理などで手軽に利用できるんじゃないかなと思います。

# ファイル指定

バッチ処理をする場合はバッチファイルを作成しますが、
このように `-f` オプションを指定することでバッチファイルを実行することができます。

# 共通テーブル式（CTE）

で、今はまだ4件だけしかデータが無いんですけど、このデータが多くなってくると、
データがどういうふうにつながっているかを見たい、というケースがでてくるかもしれません。
で、今までのMySQLだとJOINで繋ぐ方法があります。
これだとたどりたい数だけJOINを繋がないといけませんので、
現実的にはたどるのが難しい。

MySQL8.0ではCTE（共通テーブル式）という機能が追加されました。
これを使うと、再帰的にJOINを行って階層をたどることができます。

[MySQL :: MySQL 8.0 Reference Manual :: 13.2.13 WITH Syntax (Common Table Expressions)](https://dev.mysql.com/doc/refman/8.0/en/with.html)

# 共通テーブル式

SQLはこうなります。

```sql
with recursive
blockchain (id, hash, path)  as (
  select id, hash, cast(id as char(100))
  from block
  where id = 1
union all
  select b.id, b.hash, concat(bc.path, '->', b.id)
  from blockchain bc join block b
  on bc.hash = b.prev_hash
)
select * from blockchain;                        
```


[MySQL :: MySQL Shell 8.0 :: 7.2.2 Startup Scripts](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-startup-scripts.html)

実行すると、このように再帰的な結果が簡単にえられます。


# JSON_TABLE

あわせてこれもMySQL8.0の新機能のJSON_TABLE()という関数を紹介します。
これはJSON型のデータを表にしてくれる関数です。
表にできるので他のテーブルとJOINもできます。

例えばトランザクションのJSONを表にして出力する場合のSQLはこのようになります。
この部分で表のカラム定義をしています。

実行するとこうなります。

```sql
select id, trans.*
from block, JSON_TABLE(
  `transaction`,
  '$[*]'
  columns (
    `name` varchar(32) path '$.name',
    `date` date path '$.date',
    `report` varchar(128) path '$.report'
  )
) trans;
```

JOINの例です。

# 参考文献


